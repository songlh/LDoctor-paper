\section{Root-Cause Taxonomy}
\label{sec:study}

Previous work has identified a wide variety of performance root-cause 
categories. However, no existing taxonomy satisfies all the three 
requirements below and hence cannot be directly used for our diagnosis tool
design.
\begin{enumerate}
\item Coverage: covering
a big portion of real-world inefficient loop problems; 
\item Actionability: each root-cause category should be informative enough 
to help developers
decide how to fix a performance problem; 
\item Generality: application-specific root causes will not work, as we
hope to build diagnosis tools that can automatically identify root causes 
without developers' help.
\end{enumerate}


We divide all inefficient loops into two main root-cause categories,
\textit{resultless} and \textit{redundancy}, and many sub-categories under
these two.
The details of these categories will be presented below.

Our discussion below will qualitatively show that 
our taxonomy is general, not application-specific, and
cover common loop inefficiency problems.
We will quantitatively measure the coverage, actionability, and 
generality of our taxonomy
using real-world performance-bug suite in Section \ref{sec:eval_taxonomy}.


\subsection{Resultless loops}
\label{sec:study_resultless}
Resultless loops spend a lot of time in computation that does not
produce results useful after the loop (i.e., computation without side effects).
They can be further categorized to four sub-types 
based on which part of the loop is
(not) producing useful results. We explain these four sub-types below, 
as well as
how they can be fixed.


{\textbf{0*}}: 
This type of loops never produce any results in any iteration.
They are rare in mature software systems.

{\textit{How to fix?}} This type of loops should simply be deleted from the program.
%Question: dynamic or static?

\begin{figure}
\centering
\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
     morekeywords={+},keepspaces=true,numbers=left}
  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/Mozilla347306.c}}
\caption{A resultless 0*1? bug in Mozilla}
\label{fig:Mozilla347306}
\end{figure}

{\textbf{0*1?}}:
This type of loops only produce results in the last iteration, if any. 
They are often related to search: check a sequence of elements one
by one until the right one is found.
Clearly, whether these loops are efficient or not depends on the
workload. When indeed inefficient, they are often
fixed by data-structure changes.
An example is shown in Figure \ref{fig:Mozilla347306}.
Large JavaScript files often fill the \texttt{script} list with 
tens of thousands of nodes and cause poor performance.

{\textit{How to fix?}}
To make a linear search more efficient, it usually requires a data
structure change. For example, 
the patch for the bug in Figure \ref{fig:Mozilla347306}
simply replaced the \texttt{script} list with a hash table.
% This improve the performance by 52.60{\bf X}.

\comment{
This loop searches through xxx for xxx.
When xx, this loop often needs to execute xx iterations, which is very
time consuming.
The developers simply change the data-structure of xx from xx to a hash
table, which eliminates this loop and improving the performance by xxx.}
%Linhai, you have to describe examples using words people can understand
%and you have to provide useful information, such as what is the purpose
% of the loop. What is the loop searching for? What is the bug-triggering
%workload; how bad the performance (throughput or latency) was; how good
%is the fixed version in terms of performance.
\comment{
\textcolor{red}{
MySQL\#27287 is caused by linear backward searching for parent node during XML string parsing. 
In each iteration of the buggy loop, one previous sibling will be skipped, 
and in the last iteration, parent node will be returned. 
The patch applies a stack-like data structure to keep all parent nodes who have unparsed children to avoid the linear backward searching.
} } 
%Linhai, I have no idea what you are talking about here for mysql27287

%TOADD: performance diagnosis is different from bug detection%
%in many cases, there is no absolutely ``bad'' cases. performance problems are
%often a trade-off between code simplicity, performance, xxx.
%treating it like bug detection will inevitably lead to false positives
%we are providing information to developers

\begin{figure}
\centering
\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
     morekeywords={+},keepspaces=true}
  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/GCC46401.c}}
\caption{A resultless [0$|$1]* bug in GCC }
\label{fig:GCC46401}
\end{figure}


{\textbf{[0$|$1]*}}:
Each iteration in this type of loops may or may not produce results.
For some workload, the majority of iterations do not produce
results and cause performance problems perceived by users.
These problems are often solved
by adding a simple check to conditionally skip the expensive loop.
Figure~\ref{fig:GCC46401} shows such an example.
%how users perceive this problem
%explain how every iteration may or may not produce any results
%explain the fix
Users complained that compilation became extremely slow when
the \texttt{-Wsequence-point} checking is enabled.
The slowness was caused
by the \texttt{for} loop in the figure. As the algorithm
behind this loop has quadratic complexity in the number of operands in an expression, 
programs with long expressions suffer severe slow-downs.
After further diagnosis, developers observed that this loop rarely
had any side-effects, as the \texttt{if} condition was rarely satisfied.
At the end, the patch greatly improved performance through a
simple checking that allows the loop to be
skipped in most cases.

{\textit{How to fix?}}
The patch shown in Figure \ref{fig:GCC46401} reflects the typical fix
strategy for this type of inefficient loops. The developers should 
think about what exactly is the condition for the loop to produce
results, and use that condition to skip the whole loop
whenever possible.

\comment{
\textcolor{red}{ 
%For example, the patch for GCC\#46401 is to skip the sequence point checking loop when one operand is a constant string.
For example, a long expression inside the bug-triggering input exposes the super-linear 
inefficiency of checking violation of sequence point rule for GCC\#46401. 
Each operand on the expression will be compared with all previous operands on the same expression.
When fixing the bug,
developers notice that each operand on the buggy expression has a special feature which make the violation checking never 
report warning (generate results). 
The patch designed by developers is to add an extra condition checking to skip the violation checking for operands with that feature.    
}
}

{\textbf{1*}}:
Loops in this category always generate results in almost all iterations. 
They are inefficient because their results are useless due to
some high-level semantic reasons.
Understanding and fixing this type of inefficiency problems often require
deep understanding of the program and are difficult to automate.
For example, several Mozilla performance problems are caused by 
loops that contain intensive GUI operations whose graphical outcome may not
be observed by humans and hence can be optimized.

{\textit{How to fix?}}
As we can see, a deep understanding of software semantics is required
to understand the inefficiency root cause of these loops.
Similarly, the fix strategies for these loops would vary from case to case.
%At high level, the patch often involves skip some computation that produces
%side effects that are useless due to semantic reasons.

\subsection{Redundant loops}
\label{sec:study_redundant}

Redundant loops spend a lot of time in repeating computation that is already
conducted. They can be further categorized to two sub-types
based on which part of the loop is the unit of redundancy.

%\begin{figure}[h]
%\centering
%\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
%     morekeywords={+},keepspaces=true}
%  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/GCC1687.c}}
%\caption{A cross-iteration redundant bug in GCC 
% (\texttt{walk\_tree} will call itself recursively inside the loop, 
% and during buggy run, many iterations are doing exactly the same thing.)  }
%\label{fig:GCC1687}
%\end{figure}

\comment{
\begin{figure}
\centering
\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
     morekeywords={+},keepspaces=true}
  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/Mozilla490742.js}}
\caption{A cross-iteration redundant bug in Mozilla }
\label{fig:Mozilla490742}
\end{figure}
}


{\textbf{Cross-iteration Redundancy}}:
Loop iteration is the redundancy unit here:
one iteration repeats
what was already done by an earlier iteration of the same loop.
Here, we consider a recursive function as a loop, treating one function-call
instance as one loop iteration. 

{\textit{How to fix?}}
Intuitively, most redundancy problems can be fixed through memoization or
batching --- either caching the earlier computation results and skip
some of the following iterations; or combining multiple iterations' work
together.

For example, the GCC bug shown in Figure~\ref{fig:GCC27733} is caused by
redundant computation across different invocations of recursive function
\texttt{mult\_alg}. The patch essentially allows memoization to work.
%Another bug similar to GCC\#27733 is shown in Figure~\ref{fig:GCC1687}. 
%This bug is fixed by using a hash table to avoid visiting the same sub-tree twice.
\comment{
Mozilla\#490742 in Figure~\ref{fig:Mozilla490742} represents a slightly different type of cross-iteration
redundancy. The inefficient loop in this case saves one URL into the ``Favorite
Links'' database in each iteration. One database transaction in each iteration
turns out to be to time consuming, with too much redundant work across
iterations. At the end, developers decide to batch all database updates into 
one big transaction, which speeds up some workload like 
bookmarking 50 tabs 
from popping up timeout windows to not blocking.
%xxx from several minutes
%to a couple of seconds.
}

{\textbf{Cross-loop Redundancy}}:
A whole loop is the redundancy unit:
one dynamic instance of a loop spends a big chunk, if not all, of its
computation in repeating the work already done by an
earlier instance of the same loop.

{\textit{How to fix?}}
Just like that in cross-iteration redundancy, memoization and batching
are the typical fix strategies for this type of redundancy problems ---
caching the earlier computation results and skip following redundant loops;
or combining multiple loop instances together to avoid or alleviate redundancy.

Mozilla\#477564 shown in Figure~\ref{fig:Mozilla477564} is an example for this type of bugs. 
The buggy loop counts how many previous siblings of the input \texttt{aNode} have the same name and URI. 
There is an outer loop, not shown in the figure, that repeatedly updates
\texttt{aNode} to be its next sibling and calls
\texttt{sss\_xph\_generate} with the new \texttt{aNode}. 
This bug is fixed by adding an extra field for each node to save the calculated 
count, so that a new count value can be calculated by simply adding one to the
saved count value of the nearest previous sibling with the same name and URI.

\begin{figure}
\centering
\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
     morekeywords={+},keepspaces=true}
  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/Mozilla477564.js}}
\caption{A cross-loop redundant bug in Mozilla }
\label{fig:Mozilla477564}
\end{figure}



\subsection{Discussion}
Coverage, actionability, and generality are the principles behind our taxonomy
design. Intuitively, the categories above cover a lot of common inefficient
loop problems; each sub-category is concrete enough to guide the design of a
failure diagnosis tool; none of the categories above involve any application
specific knowledges or heuristics. We will further assess our taxonomy
through the design of \Tool (Section \ref{sec:design}) and 
real-world bug study (Section \ref{sec:eval_taxonomy}).

Of course, our taxonomy does not cover \emph{all} loop inefficiency problems.
For example, some loops may be vulnerable to false sharing problems or lock
contention problems, which are out of the scope of our taxonomy. 
