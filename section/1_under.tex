\section{Root-Cause Taxonomy}
\label{sec:study}


Previous work has identified a wide variety of performance root-cause 
categories. However, no existing taxonomy satisfies all the three 
requirements below and hence cannot be directly used for our diagnosis tool
design.
\begin{enumerate}
\item Coverage: covering
a big portion of real-world inefficient loop problems; 
\item Actionability: each root-cause category should be informative enough 
to help developers
decide how to fix a performance problem; 
\item Generality: application-specific root causes will not work, as we
hope to build diagnosis tools that can automatically identify root causes 
without developers' help.
\end{enumerate}

This section first presents the root-cause taxonomy designed by us, 
and then discusses the coverage, actionability, and generality
of our taxonomy using a suite of real-world
inefficient loops collected by previous work \cite{SongOOPSLA2014,PerfBug}. 



\subsection{Taxonomy Design}
\label{sec:study_tax}
We divide all inefficient loops into two root-cause categories:
\textit{resultless} and \textit{redundancy}.

\subsubsection{Resultless loops}
A resultless loop spends a lot of time in computation without
producing results useful after the loop.
It is further categorized based on which loop iterations are
(not) producing useful results.


{\textbf{0*}}: 
This type of loops never produce any results in any iteration.
They are rare in mature software systems.
They should simply be deleted from the program.
%Question: dynamic or static?

\begin{figure}
\centering
\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
     morekeywords={+},keepspaces=true,numbers=left}
  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/Mozilla347306.c}}
\vspace{-0.05in}
\caption{A resultless 0*1? bug in Mozilla}
\label{fig:Mozilla347306}
\end{figure}

{\textbf{0*1?}}:
This type of loops only produce results in the last iteration, if any. 
They are often related to search: check a sequence of elements one
by one until the right one is found.
Clearly, whether these loops are efficient or not depends on the
workload. When indeed inefficient, they are often
fixed by data-structure changes.
An example is shown in Figure \ref{fig:Mozilla347306}.
Large JavaScript files often fill the \texttt{script} list with 
tens of thousands of nodes and cause poor performance.
The patch simply replaced the \texttt{script} list with a hash table.
% This improve the performance by 52.60{\bf X}.

\comment{
This loop searches through xxx for xxx.
When xx, this loop often needs to execute xx iterations, which is very
time consuming.
The developers simply change the data-structure of xx from xx to a hash
table, which eliminates this loop and improving the performance by xxx.}
%Linhai, you have to describe examples using words people can understand
%and you have to provide useful information, such as what is the purpose
% of the loop. What is the loop searching for? What is the bug-triggering
%workload; how bad the performance (throughput or latency) was; how good
%is the fixed version in terms of performance.
\comment{
\textcolor{red}{
MySQL\#27287 is caused by linear backward searching for parent node during XML string parsing. 
In each iteration of the buggy loop, one previous sibling will be skipped, 
and in the last iteration, parent node will be returned. 
The patch applies a stack-like data structure to keep all parent nodes who have unparsed children to avoid the linear backward searching.
} } 
%Linhai, I have no idea what you are talking about here for mysql27287

%TOADD: performance diagnosis is different from bug detection%
%in many cases, there is no absolutely ``bad'' cases. performance problems are
%often a trade-off between code simplicity, performance, xxx.
%treating it like bug detection will inevitably lead to false positives
%we are providing information to developers

\begin{figure}
\centering
\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
     morekeywords={+},keepspaces=true}
  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/GCC46401.c}}
\vspace{-0.05in}
\caption{A resultless [0$|$1]* bug in GCC }
\label{fig:GCC46401}
\end{figure}


{\textbf{[0$|$1]*}}:
Each iteration in this type of loops may or may not produce results.
For some workload, the majority of iterations do not produce
results and cause performance problems perceived by users.
These problems are often solved
by adding a simple check to conditionally skip the expensive loop.
Figure~\ref{fig:GCC46401} shows such an example.
%how users perceive this problem
%explain how every iteration may or may not produce any results
%explain the fix
Users complained that compilation became extremely slow when
the \texttt{-Wsequence-point} checking is enabled.
The slowness was caused
by the \texttt{for} loop in the figure. As the algorithm
behind this loop has quadratic complexity in the number of operands in an expression, 
programs with long expressions suffer severe slow-downs.
After further diagnosis, developers observed that this loop rarely
had any side-effects, as the \texttt{if} condition was rarely satisfied.
At the end, the patch greatly improved performance through a
simple checking that allows the loop to be
skipped in most cases.

\comment{
\textcolor{red}{ 
%For example, the patch for GCC\#46401 is to skip the sequence point checking loop when one operand is a constant string.
For example, a long expression inside the bug-triggering input exposes the super-linear 
inefficiency of checking violation of sequence point rule for GCC\#46401. 
Each operand on the expression will be compared with all previous operands on the same expression.
When fixing the bug,
developers notice that each operand on the buggy expression has a special feature which make the violation checking never 
report warning (generate results). 
The patch designed by developers is to add an extra condition checking to skip the violation checking for operands with that feature.    
}
}

{\textbf{1*}}:
Loops in this category always generate results in almost all iterations. 
They are inefficient because their results are useless due to
some high-level semantic reasons.
Understanding and fixing this type of inefficiency problems often require
deep understanding of the program and are difficult to automate.
For example, several Mozilla performance problems are caused by 
loops that contain intensive GUI operations whose graphical outcome may not
be observed by humans and hence can be optimized.

\subsubsection{Redundant loops}
Redundant loops spend a lot of time in repeating computation that is already
conducted. They are further categorized below based on their redundancy unit.

%\begin{figure}[h]
%\centering
%\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
%     morekeywords={+},keepspaces=true}
%  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/GCC1687.c}}
%\caption{A cross-iteration redundant bug in GCC 
% (\texttt{walk\_tree} will call itself recursively inside the loop, 
% and during buggy run, many iterations are doing exactly the same thing.)  }
%\label{fig:GCC1687}
%\end{figure}

\comment{
\begin{figure}
\centering
\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
     morekeywords={+},keepspaces=true}
  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/Mozilla490742.js}}
\caption{A cross-iteration redundant bug in Mozilla }
\label{fig:Mozilla490742}
\end{figure}
}

\begin{figure}
\centering
\lstset{basicstyle=\ttfamily\fontsize{8}{8}\selectfont,
     morekeywords={+},keepspaces=true}
  \mbox{\lstinputlisting[mathescape,boxpos=t]{figures/Mozilla477564.js}}
\vspace{-0.05in}
\caption{A cross-loop redundant bug in Mozilla }
\label{fig:Mozilla477564}
\end{figure}


{\textbf{Cross-iteration Redundancy}}:
Loop iteration is the redundancy unit here:
one iteration repeats
what was already done by an earlier iteration of the same loop.
Here, we consider a recursive function as a loop, treating one function-call
instance as one loop iteration. 

This type of inefficiency is often fixed by memoization or batching, depending
on whether the redundancy involves I/O operations.
For example, the GCC bug shown in Figure~\ref{fig:GCC27733} is caused by
redundant computation across different invocations of recursive function
\texttt{mult\_alg}. The patch essentially allows memoization to work.
%Another bug similar to GCC\#27733 is shown in Figure~\ref{fig:GCC1687}. 
%This bug is fixed by using a hash table to avoid visiting the same sub-tree twice.
\comment{
Mozilla\#490742 in Figure~\ref{fig:Mozilla490742} represents a slightly different type of cross-iteration
redundancy. The inefficient loop in this case saves one URL into the ``Favorite
Links'' database in each iteration. One database transaction in each iteration
turns out to be to time consuming, with too much redundant work across
iterations. At the end, developers decide to batch all database updates into 
one big transaction, which speeds up some workload like 
bookmarking 50 tabs 
from popping up timeout windows to not blocking.
%xxx from several minutes
%to a couple of seconds.
}

{\textbf{Cross-loop Redundancy}}:
A whole loop is the redundancy unit:
one dynamic instance of a loop spends a big chunk, if not all, of its
computation in repeating the work already done by an
earlier instance of the same loop.
Developers often fix this type of inefficiency problems through memoization:
caching the earlier computation results and skip following redundant loops.
Mozilla\#477564 shown in Figure~\ref{fig:Mozilla477564} is an example for this type of bugs. 
The buggy loop counts how many previous siblings of the input \texttt{aNode} have the same name and URI. 
There is an outer loop, not shown in the figure, that repeatedly updates
\texttt{aNode} to be its next sibling and calls
\texttt{sss\_xph\_generate} with the new \texttt{aNode}. 
This bug is fixed by adding an extra field for each node to save the calculated 
count, so that a new count value can be calculated by simply adding one to the
saved count value of the nearest previous sibling with the same name and URI.


\input section/tab_root

\input section/tab_appbug

\subsection{Taxonomy Assessment}
\label{sec:tax_study}
We assess the coverage, actionability, and generality of our taxonomy using
a set of
real-world inefficient loop problems collected by previous work
\cite{SongOOPSLA2014,PerfBug}.


\subsubsection{Methodology}

Previous work \cite{PerfBug,SongOOPSLA2014} studied the on-line bug
databases of five representative open-source software projects, as 
shown in Table \ref{tab:app_bug}. Through a mix of random sampling and 
manual inspection, they 
found 65 performance problems that are perceived and reported by users. 
Among these 65 problems, 45 problems are related to inefficient loops and 
hence are the target of the study 
here\footnote{The definition of ``loop-related'' in this paper is a little
bit broader than earlier paper~\cite{SongOOPSLA2014}, which only considers
43 problems as loop-related. }.
More details can be found in previous papers that collected
these bugs. 

\subsubsection{Assessment}
\label{sec:study_ob}

\comment{
\begin{table*}[tb!]
%\begin{adjustwidth}{-.5in}{-.5in}
\small
\centering
{
\begin{tabular}{|lcccccc|}
\hline
&Apache&Chrome&GCC&Mozilla&MySQL&Total\\
\hline
Total \# of loop bugs & 11 & 4 & 8 & 12 & 10 & 45 \\
\hline
\multicolumn{1}{|l}{Cross-{\bf iteration} Redundancy}
&7&1&2&1&1&12\\
\multicolumn{1}{|l}{ Cross-{\bf loop} Redundancy}
&3&0&2&2&2&9\\
\multicolumn{1}{|l}{ {\bf 0*} Resultless}
&0&0&0&0&0&0\\
\multicolumn{1}{|l}{ {\bf 0*1?} Resultless}
&0&0&0&2&3&5\\
\multicolumn{1}{|l}{{\bf [0$|$1]*} Resultless}
&0&1&1&1&1&4\\
\multicolumn{1}{|l}{{\bf 1*} Resultless}
&1&2&3&6&3&15\\
%&0&2&0&5&0&7&B(4)$|$S(3)\\
%&1&0&3&1&3&8&\\
  %MySQL15811 is moved from 1* to here; consider it as fixed by M
%\hline
%\multicolumn{8}{|c|}{ \# of {\textit {Other}} bugs}\\
%\multicolumn{1}{|l}{Not in above categories}
\hline
\end{tabular}
}
%\end{adjustwidth}
\caption{Number of bugs in each root-cause category. 
}
\label{tab:root}
\end{table*}
}



\comment{
\def\cca#1{\cellcolor{black!#10}\ifnum #1>5\color{white}\fi{#1}}
%For ranges 0-10, multiply by 10 by adding 0 after #1
\begin{table}[tb!]
%\begin{adjustwidth}{-.5in}{-.5in}
\small
\centering
{
\begin{tabular}{lcccccc}
%\hline
                                 &{\bf 0*}    & {\bf 0*1?} & {\bf [0$|$1]*}   & {\bf 1*} & {\bf C-I}  & {\bf C-L} \\
%\hline
 B                               & \cca{0}    & \cca{0}    & \cca{0}          & \cca{4}  & \cca{4}     & \cca{4}   \\
%\hline
 M                               & \cca{0}    & \cca{0}    & \cca{0}          & \cca{0}  & \cca{7}     & \cca{5}   \\
 S                               & \cca{0}    & \cca{1}    & \cca{4}          & \cca{4}  & \cca{0}     & \cca{0}   \\
 C                               & \cca{0}    & \cca{4}    & \cca{0}          & \cca{0}  & \cca{0}     & \cca{0}   \\
 O                               & \cca{0}    & \cca{0}    & \cca{0}          & \cca{7}  & \cca{1}     & \cca{0}   \\
%\hline

\end{tabular}
}
%\end{adjustwidth}
\caption{Number of bugs fixed by each strategy:
B(atching),  
M(emoization), 
S(kipping the loop),
C(hange the data structure), and O(thers). 
``C-I'': cross- iteration redundancy. 
``C-L'': cross-loop redundancy. 
}
\label{tab:correlation}
\end{table}
}


\paragraph{Coverage}
As shown in Table \ref{tab:root}, 
our taxonomy does cover all inefficient loops under study. 
Resultless loops are about as common as redundant loops
(24 vs. 21).
Not surprisingly, 0* loops
are rare in mature software. In fact, no bugs in this
benchmark suite belong to this category.
All other root-cause sub-categories are well represented.


\paragraph{Actionability}
As demonstrated in Table \ref{tab:root}, 
the root-cause categories in our taxonomy are well correlated with
fix strategies.
This indicates that our taxonomy is actionable --- once the root cause
is identified, developers roughly know how to fix the problem.
For example, 
almost all 0*1? resultless loops are fixed by data-structure changes;
all [0$|$1]* resultless loops are
fixed by conditionally skipping the loop;
almost all redundant loops are fixed either by 
memoization or batching. 
In fact, as we will discuss later, simple analysis can tell whether 
memoization or batching should be used to fix a redundant loop.
The only problem is that there are no silver bullets for fixing 1* loops.
%all inefficient loops with xx root cause are fixed by xxx.
%xxx

\paragraph{Generality}
The root-cause categories in our taxonomy are designed to be 
generic. Table \ref{tab:root} also shows that these categories 
each appears in multiple
application in our study. The only exception is $0^*$-resultless, which
never appears. 


In summary, the study above informally demonstrates that our taxonomy
is suitable to guide our design of \Tool.
%chances to satisfy the coverage and accuracy requirements of performance 
%diagnosis.
%
%TODO even for the other, there are things we could do ...

\subsubsection{Caveats} 
Just as previous empirical study work, 
our empirical study above needs to be interpreted with our methodology in mind. 
The performance bugs examined above cover a variety of applications, workload, 
development environments and programming languages. 
However, there are still uncovered cases, like distributed systems, 
and scientific computation. 

Previous work~\cite{PerfBug, SongOOPSLA2014} uses developers tagging and
on-line discussion to judge whether a bug report is about
performance problems and whether 
the performance problem under discussion is noticed and reported by users
or not.
We follow the methodology used in previous work~\cite{SongOOPSLA2014} to judge 
whether the root-cause of a performance problem is related to loops or not.
We do not intentionally ignore any aspect of loop-related performance problems. 
Some loop-related performance problems may never be noticed by end users
or never be fixed by developers, and hence skip our study. However,
there are no conceivable ways to study them. 

\comment{
We believe that the bugs in our study provide a representative sample of the 
well-documented and
fixed performance bugs that are user-perceived and loop-related in the studied 
applications. 
Since we did not set up the root-cause taxonomy to fit particular
bugs in this bug benchmark suite, we believe our taxonomy and diagnosis
framework presented below will go beyond these sampled performance bugs. 
}
